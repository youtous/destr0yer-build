input {
  tcp {
    port => 5000
    type => syslog
    ssl_enable => true
    ssl_certificate_authorities => ["/etc/ca.crt"]
    ssl_cert => "/etc/server.crt"
    ssl_key => "/etc/server.key"
    ssl_verify => true
  }
  http {
    host => "0.0.0.0"
    port => "8080"
    type => "http-input"
  }
  # http listener used for healthchecking only
  http {
    host => "0.0.0.0"
    port => "8082"
    type => "elb-healthcheck"
  }
}

filter {
  if [type] == "elb-healthcheck" {
    drop {}
  }
  if [type] == "syslog" {
    grok {
      match => {"message" => "%{SYSLOG5424PRI}%{NONNEGINT:ver} +(?:%{TIMESTAMP_ISO8601:ts}|-) +(?:%{HOSTNAME:containerhost}|-) +(?:%{NOTSPACE:containername}|-) +(?:%{NOTSPACE:proc}|-) +(?:%{WORD:msgid}|-) +(?:%{SYSLOG5424SD:sd}|-|) +%{GREEDYDATA:msg}"}
    }
    syslog_pri {}
    date {
      match => ["syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss"]
    }
    mutate {
      remove_field => ["message", "priority", "ts", "severity", "facility", "facility_label", "severity_label", "syslog5424_pri", "proc", "syslog_severity_code", "syslog_facility_code", "syslog_facility", "syslog_severity", "syslog_hostname", "syslog_message", "syslog_timestamp", "ver"]
    }
    mutate {
      remove_tag => ["_grokparsefailure_sysloginput"]
    }
    if [msg] =~ "^ *{" {
      json {
        source => "msg"
      }
      if "_jsonparsefailure" in [tags] {
        drop {}
      }
      mutate {
        remove_field => ["msg"]
      }
    }
    if [containername] =~ "^traefik*" {
        grok {
            match => {
                "msg" =>  "%{IPORHOST:traefik.access.remote_ip} - %{DATA:traefik.access.user_name} \[%{HTTPDATE:traefik.access.time}\] \"%{WORD:traefik.access.method} %{DATA:traefik.access.url} HTTP/%{NUMBER:traefik.access.http_version}\" %{NUMBER:traefik.access.response_code} (?:%{NUMBER:traefik.access.body_sent.bytes}|-)( \"%{DATA:traefik.access.referrer}\")?( \"%{DATA:traefik.access.agent}\")?(?: %{NUMBER:traefik.access.request_count}|-)?( \"%{DATA:traefik.access.frontend_name}\")?( \"%{DATA:traefik.access.backend_url}\")?( %{NUMBER:temp.duration:long}ms)?"
            }
        }
        if "_grokparsefailure" in [tags] {
            # not a request message for traefik, continue...
            mutate {
                remove_tag => ["_grokparsefailure"]
            }
        } else {
            # processing traefik message
            mutate {
                remove_field => ["msg"]
            }
            mutate {
                rename => {"@timestamp" => "event.created"}
            }
            date {
                match => ["traefik.access.time", "dd/MMM/yyyy:H:m:s Z"]
                target => ["@timestamp"]
            }
            mutate {
                remove_field => ["traefik.access.time"]
            }
            mutate {
                convert => {
                    "traefik.acess.response_code" => "integer"
                }
            }
            useragent {
                source => "traefik.access.agent"
                target => "user_agent"
            }
            geoip
            {
                source => "traefik.access.remote_ip"
                target => "source.geo"
            }
        }
    }
    if ("" in [msg]) {
        mutate {
            rename => {"msg" => "message"}
        }
    }
    mutate {
        remove_field => ["tags"]
    }
  }
}

output {
  elasticsearch { hosts => ["elasticsearch:9200"] }
}
