---
version: '3.8'

services:

  # this stack act as a forwarder to an other logstash entrypoint

  # process logs from everywhere
  logstash:
    image: "opensearchproject/logstash-oss-with-opensearch-output-plugin:{{ logstash_elastic_version }}"
    configs:
      - source: logstash.yml
        target: /usr/share/logstash/config/logstash.yml
      - source: pipelines.yml
        target: /usr/share/logstash/config/pipelines.yml
{% for pipeline in logstash_pipeline_files %}
      - source: "pipeline_{{ pipeline }}"
        target: "/usr/share/logstash/pipeline-main/{{ pipeline }}"
{% endfor %}
{% for grok in logstash_pipeline_patterns %}
      - source: "pattern_{{ grok }}"
        target: "/usr/share/logstash/pipeline-main/patterns.d/{{ grok }}"
{% endfor %}
    secrets:
      - source: logstash-rootCA.crt
        target: /etc/ca.crt
      - source: logstash-certificate.crt
        target: /etc/server.crt
      - source: logstash-private-key.key
        target: /etc/server.key
      - source: logstash-client-rootCA.crt
        target: /etc/ca-client.crt
      - source: logstash-client-certificate.crt
        target: /etc/client.crt
      - source: logstash-client-private-key.key
        target: /etc/client.key
    environment:
      - "LS_JAVA_OPTS=-Xms{{ logstash_memory }}m -Xmx{{ logstash_memory }}m -Djdk.tls.disabledAlgorithms=\"{{ elastic_disabled_tls_protocols|join(',') }}\""
      - "ELASTIC_CLUSTER_NAME=${ELASTIC_CLUSTER_NAME}"
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.labels.logstash_host == true
        preferences:
          - spread: node.id
        max_replicas_per_node: 1
      restart_policy:
        condition: on-failure
        delay: 5s
        window: 30s
        max_attempts: 0 # unlimited restarts
      resources:
        limits:
          memory: "{{ logstash_memory }}M"
        reservations:
          memory: "{{ logstash_memory_reservation }}M"
      labels:
        # traefik (tcp)
        traefik.enable: "true"
        traefik.docker.network: "{{ traefik_public_network }}"

        
        traefik.tcp.routers.logstash-5000.entrypoints: "logstash5000"

        traefik.tcp.routers.logstash-5000.rule: "HostSNI(`*`)"
        traefik.tcp.routers.logstash-5000.tls.passthrough: "true"
        traefik.tcp.routers.logstash-5000.service: "logstash-5000-proxy"
        traefik.tcp.routers.logstash-5000.middlewares: "logstash-ipwhitelist@docker"
        
        traefik.tcp.services.logstash-5000-proxy.loadbalancer.server.port: "5000"
        traefik.tcp.services.logstash-5000-proxy.loadbalancer.terminationDelay: "60000"


        traefik.tcp.routers.logstash-5044.entrypoints: "logstash5044"

        traefik.tcp.routers.logstash-5044.rule: "HostSNI(`*`)"
        traefik.tcp.routers.logstash-5044.tls.passthrough: "true"
        traefik.tcp.routers.logstash-5044.service: "logstash-5044-proxy"
        traefik.tcp.routers.logstash-5044.middlewares: "logstash-ipwhitelist@docker"
        
        traefik.tcp.services.logstash-5044-proxy.loadbalancer.server.port: "5044"
        traefik.tcp.services.logstash-5044-proxy.loadbalancer.terminationDelay: "60000"


        traefik.tcp.routers.logstash-5064.entrypoints: "logstash5064"

        traefik.tcp.routers.logstash-5064.rule: "HostSNI(`*`)"
        traefik.tcp.routers.logstash-5064.tls.passthrough: "true"
        traefik.tcp.routers.logstash-5064.service: "logstash-5064-proxy"
        traefik.tcp.routers.logstash-5064.middlewares: "logstash-external-ipwhitelist@docker"
        
        traefik.tcp.services.logstash-5064-proxy.loadbalancer.server.port: "5064"
        traefik.tcp.services.logstash-5064-proxy.loadbalancer.terminationDelay: "60000"
        
        traefik.tcp.middlewares.logstash-ipwhitelist.ipwhitelist.sourcerange: "{{ logstash_allowed_ips|join(', ') }}, 127.0.0.1/32" 
        traefik.tcp.middlewares.logstash-external-ipwhitelist.ipwhitelist.sourcerange: "{{ logstash_external_allowed_ips|join(', ') }}, 127.0.0.1/32"

        # todo : eventually enable TCP Keepalive when supported by traefik https://github.com/traefik/traefik/issues/1046

# TODO: enable it when supported, actually not yet supported https://github.com/traefik/traefik/issues/5598
#   
#         traefik.tcp.services.logstashproxy.loadbalancer.healthCheck.path: "/health?ready=1"
#         traefik.tcp.services.logstashproxy.loadbalancer.healthCheck.scheme: "http"
#         traefik.tcp.services.logstashproxy.loadbalancer.healthCheck.port: "8080"
#         traefik.tcp.services.logstashproxy.loadbalancer.healthCheck.interval: "10s"
#         traefik.tcp.services.logstashproxy.loadbalancer.healthCheck.timeout: "3s"
# 

{% if enable_logstash_webui %}

        caddy: "{{ logstash_domain }}"

        # hsts headers (see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security)
        caddy.1_header.Strict-Transport-Security: "\"max-age=63072000; includeSubDomains; preload\""

        # security labels
        caddy.1_header.-Server: ""
        caddy.1_header.-X-Powered-By: ""
        caddy.1_header.Permissions-Policy: "\"accelerometer=(), camera=(), interest-cohort=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), payment=(), usb=()\"" # see best practices https://github.com/w3c/webappsec-permissions-policy/blob/master/features.md, https://developer.mozilla.org/en-US/docs/Web/HTTP/Feature_Policy
        caddy.1_header.Referrer-Policy: "same-origin"
        caddy.1_header.X-Content-Type-Options: "nosniff"
        caddy.1_header.X-Frame-Options: "DENY"
        caddy.1_header.X-XSS-Protection: "\"1; mode=block\""
        caddy.1_header.Content-Security-Policy: "\"default-src 'self'; script-src 'self'; img-src 'self'; style-src 'self'; font-src 'self'; frame-ancestors 'self'; frame-src 'self'; object-src 'none';\"" # https://csp-evaluator.withgoogle.com/ content security policy

        # ip filter auth & reverse proxy conf
        caddy.2_@ipfilter.remote_ip: "{{ elastic_allowed_ips|join(' ') }} 127.0.0.1"

        # apply ip filter
        caddy.3_handle: "@ipfilter"
        # basic auth
        caddy.3_handle.1_basicauth: "/*" # route matcher to protect
{% for authuser in elastic_backend_users %}
{% set user_loc = authuser.split(':') %}
        caddy.3_handle.1_basicauth.{{ user_loc[0] }}: "{{ user_loc[1] | replace('$', '$$') }}" # because '$' is evaluated, remember to escape it
{% endfor %}
        # try to match filter for a reverse proxy to upstream (eventually add load balancing etc)
        caddy.3_handle.2_reverse_proxy: "{% raw %}{{upstreams 8080}}{% endraw %}"
        caddy.3_handle.2_reverse_proxy.lb_policy: "round_robin"
        caddy.3_handle.2_reverse_proxy.health_uri: "/"
        caddy.3_handle.2_reverse_proxy.health_interval: "5s"

        # or reject
        caddy.4_respond: "`Origin not allowed` 403"
{% endif %}
    networks:
      - stack
{% if enable_logstash_webui %}
      - {{ caddy_network }}
{% endif %}
      - {{ traefik_public_network }}
    healthcheck:
      test: curl --silent --output --fail http://localhost:9600 || exit 1
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 300s

networks:
  stack: # encrypted if Swarm want to split services on managers
    driver: overlay
{% if elastic_internal_network_encryption_enabled %}
    driver_opts:
      encrypted: ""
{% endif %}
  {{ caddy_network }}:
    external: true
  {{ traefik_public_network }}:
    external: true

# documentation about keystore https://nicklang.com/posts/learning-to-love-the-keystore
# an other way to store sensible information but in this case, the user of the docker-cluster already have privileged access
configs:
  logstash.yml:
    name: "{{ docker_elastic_stack_name }}_logstash.j2.yml-${DEPLOY_TIMESTAMP}"
    file: ./config/logstash/logstash.j2.yml
  pipelines.yml:
    name: "{{ docker_elastic_stack_name }}_pipelines.j2.yml-${DEPLOY_TIMESTAMP}"
    file: ./config/logstash/pipelines.j2.yml

{% for pipeline in logstash_pipeline_files %}
  pipeline_{{ pipeline }}:
    name: "{{ docker_elastic_stack_name }}_{{ pipeline }}-${DEPLOY_TIMESTAMP}"
    file: "./config/logstash/pipeline/{{ pipeline }}"
{% endfor %}
{% for grok in logstash_pipeline_patterns %}
  pattern_{{ grok }}:
    name: "{{ docker_elastic_stack_name }}_{{ grok }}-${DEPLOY_TIMESTAMP}"
    file: "./config/logstash/pipeline/patterns.d/{{ grok }}"
{% endfor %}

secrets:
  logstash-rootCA.crt:
    name: "{{ docker_elastic_stack_name }}_logstash-rootCA.crt-${DEPLOY_TIMESTAMP}"
    external: true
  logstash-certificate.crt:
    name: "{{ docker_elastic_stack_name }}_logstash-certificate.crt-${DEPLOY_TIMESTAMP}"
    external: true
  logstash-private-key.key:
    name: "{{ docker_elastic_stack_name }}_logstash-private-key.key-${DEPLOY_TIMESTAMP}"
    external: true
  logstash-client-rootCA.crt:
    name: "{{ docker_elastic_stack_name }}_logstash-client-rootCA.crt-${DEPLOY_TIMESTAMP}"
    external: true
  logstash-client-certificate.crt:
    name: "{{ docker_elastic_stack_name }}_logstash-client-certificate.crt-${DEPLOY_TIMESTAMP}"
    external: true
  logstash-client-private-key.key:
    name: "{{ docker_elastic_stack_name }}_logstash-client-private-key.key-${DEPLOY_TIMESTAMP}"
    external: true
